//use storage::{Storage};
use storage_traits::storage_thread::{StorageThread, Storage};
use storage::storage_thread::StorageThreadFactory;

use sdl2;
use sdl2::event::{Event,WindowEventId};
use sdl2::rect::{Rect};
use sdl2::render::Renderer;
use common::Position;

use viewport::Viewport;

pub struct Engine {
    viewport: Viewport,
    storage: Storage,
    window_size: (u32, u32),
}

impl Engine {
    pub fn new() -> Self {
        Engine {
            storage: Storage::new(StorageThreadFactory::new()),
            viewport: Viewport::default(),
            window_size: (640,480),
        }
    }

    pub fn run(&mut self) {
        // start sdl2 with everything
        let ctx = sdl2::init().unwrap();
        let video_ctx = ctx.video().unwrap();
        
        // Create a window
        let window  = match video_ctx.window("eg03", self.window_size.0, self.window_size.1).position_centered().opengl().build() {
            Ok(window) => window,
            Err(err)   => panic!("failed to create window: {}", err)
        };

        // Create a rendering context
        let mut renderer = match window.renderer().build() {
            Ok(renderer) => renderer,
            Err(err) => panic!("failed to create renderer: {}", err)
        };

        let mut events = ctx.event_pump().unwrap();
        'mainloop : loop {
            for event in events.poll_iter() {
                match event {
                    Event::Quit{..} => break 'mainloop,
                    Event::Window{win_event_id, data1, data2 ..}  => {
                        match win_event_id {
                            WindowEventId::Resized | WindowEventId::SizeChanged | WindowEventId::Maximized => {
                                self.window_size = (data1, data2);
                            }
                            _ => {}
                        }
                    }
                    _               => {
                        println!("Got event: {:?}",  event);
                        continue
                    }
                }
            }

            self.render(&mut renderer);
        } 
    }

    pub fn render(&mut self, renderer: &mut Renderer){
        let x_tile = self.viewport.x_tile;
        let y_tile = self.viewport.y_tile;

        let max_tiles = (
            (self.window_size.0 / self.viewport.tile_size) as i64 + 2,
            (self.window_size.1 / self.viewport.tile_size) as i64 + 2,
        );

        let start_tile = (
            x_tile - max_tiles.0/2,
            y_tile - max_tiles.1/2,
        );
        let end_tile = (
            x_tile + max_tiles.0/2,
            y_tile + max_tiles.1/2,
        );

        renderer.set_draw_color(sdl2::pixels::Color::RGB(0,0,0));
        renderer.clear();

        for cur_tile_x in start_tile.0..end_tile.0 {
            for cur_tile_y in start_tile.1..end_tile.1 {
                let cur_tile = Position{x: cur_tile_x, y: cur_tile_y};
                self.storage.get_cell(cur_tile).and_then(|cell| {
                    if cell.terrain == "sand" {
                        renderer.set_draw_color(sdl2::pixels::Color::RGB(255,255,170));
                    } else {
                        renderer.set_draw_color(sdl2::pixels::Color::RGB(85,41,0));
                    }
                    
                    let border_rect = Rect::new(
                        (self.window_size.0 as i32 /2) + (cur_tile_x * self.viewport.tile_size as i64) as i32 - self.viewport.x_pixels as i32,
                        (self.window_size.1 as i32 /2) + (cur_tile_y * self.viewport.tile_size as i64) as i32 - self.viewport.y_pixels as i32,
                        self.viewport.tile_size,
                        self.viewport.tile_size,
                    ).unwrap().unwrap();
                    //println!("drawing rect: {:?}", border_rect);
                    let _ = renderer.fill_rect(border_rect);
                    Ok(())
                });
                
            }
        }

        renderer.present();
    }
}

#[test]
fn basic_test() {
    Engine::new();
}
